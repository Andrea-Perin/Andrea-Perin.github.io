<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Riemannian distance for SPD circulant matrices | Andrea Perin </title> <meta name="author" content="Andrea Perin"> <meta name="description" content="Or slicing cones"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%90&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://andrea-perin.github.io/blog/2024/circulant_distance/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Riemannian distance for SPD circulant matrices",
            "description": "Or slicing cones",
            "published": "December 19, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Andrea </span> Perin </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Riemannian distance for SPD circulant matrices</h1> <p>Or slicing cones</p> </d-title> <d-article> <p>I was working on some homework for a course on <em>Geometric Deep Learning</em>. The context was differential geometry, more specifically the manifold of Symmetric Positive Definite (SPD) matrices. The exercise had us thinking about a notion of distance for this manifold. It also was presenting it as an example of the algebraic concept of a <a href="https://en.wikipedia.org/wiki/Convex_cone" rel="external nofollow noopener" target="_blank">convex cone</a>. I was left wondering: where do <em>circulant matrices</em> live in all of this?</p> <h3 id="spd-matrices">SPD matrices</h3> <p>If you end up on this page, I take it for granted you know what a symmetric matrix is. As for the Positive Definite part, the way I think about them is like a “stretching” operator: feed it any vector, and this thing will:</p> <ol> <li>rotate it to “align it” to an orthogonal basis;</li> <li>stretch/scale every component by a strictly positive number;</li> <li>undo the rotation you did at the beginning. Importantly, an positive definite matrix has strictly positive determinant.</li> </ol> <p>More info is <a href="https://en.wikipedia.org/wiki/Definite_matrix" rel="external nofollow noopener" target="_blank">on Wikipedia</a>, of course.</p> <p>You may find SPD matrices in the following contexts:</p> <ul> <li>as <em>covariance matrices</em> (if it is a <em>sample</em> covariance, you may need “enough” samples, so that it is not rank deficient);</li> <li>as <em>metric tensors</em>, once you specify some coordinate system;</li> <li>as <em>Gram matrices</em>, in the context of kernel methods;</li> <li>and, I assume, many more.</li> </ul> <h3 id="the-manifold-of-spd-matrices">The manifold of SPD matrices</h3> <p>Imagine an $n\times n$ matrix $\mathcal{M}$ that is symmetric and positive definite. Due to its symmetry, you only actually need to specify $n(n+1)/2$ elements to characterize the matrix. You can then think of this matrix as a point in the space $\mathbb{R}^{n(n+1)/2}$. The set of all such points that correspond to a symmetric positive definite matrix forms a <em>manifold</em>. It is possible to endow this manifold with a <em>metric</em>, that is, a way to “measure distance” between two of its points, thus creating a <em>Riemannian manifold</em>. We call this manifold $\mathcal{S}_{++}^n$.</p> <p>A careful discussion of Riemannian manifolds is a bit outside of my capabilities, but resources are plentiful if you crave some big boy maths.</p> <p>It is instructive and amusing to check what this manifold may look like in practice. Choose $n=2$, so that matrices (which are symmetric!) are of the type</p> \[\mathcal{M} = \begin{pmatrix} x &amp; z \\ z &amp; y \end{pmatrix}.\] <p>Additionally, we need to satisfy the requirements $\det \mathcal{M} = xy - z^2 &gt;0$, and $x&gt;0, y&gt;0$ (this is because of the positive-definiteness requirement). The matrix $\mathcal{M}$ can be represented as the point $(x, y, z)\in \mathbb{R}^3$. The manifold is then the subset of $\mathbb{R}^3$ which satisfies these requirements:</p> <ul> <li>$xy -z^2&gt;0$;</li> <li>$x&gt;0$;</li> <li>$y&gt;0$.</li> </ul> <p>Feed this to <code class="language-plaintext highlighter-rouge">matplotlib</code>, and you get this:</p> <div class="row mt-3 justify-content-center"> <div class="col-8 mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/posts/circulant_distance/cone.png" alt="The convex cone structure for a 2D SPD matrix."> </div> </div> <div class="caption"> The convex cone structure for a 2D SPD matrix. </div> <p>This really looks like a <em>geometric</em> cone, and it also happens to be an <a href="https://en.wikipedia.org/wiki/Convex_cone" rel="external nofollow noopener" target="_blank"><em>algebraic</em> cone</a>.</p> <h3 id="distance-between-spd-matrices">Distance between SPD matrices</h3> <p>One can define a notion of distance between two SPD matrices $P, Q \in \mathcal{S}_{++}^n$, as done in <a href="http://www.ipb.uni-bonn.de/pdfs/Forstner1999Metric.pdf" rel="external nofollow noopener" target="_blank">this paper</a>: The formula looks like this:</p> \[d(P, Q) = \sqrt{\sum_{i=1}^n \ln^2 \lambda_i(P, Q)},\] <p>where $\lambda_i(P, Q)$ denotes the $i$-th eigenvalue that can be obtained by solving the equation</p> \[\det(\lambda P - Q) = 0.\] <h4 id="geodesics">Geodesics</h4> <p>Similarly, we can define a <em>geodesic</em> between two SPD matrices, $P, Q \in \mathcal{S}_{++}^n$, with the following formula:</p> \[\gamma(t) = P^{1/2}(P^{-1/2}QP^{-1/2})^tP^{1/2}, \quad t\in[0,1].\] <p>For any $t\in[0, 1]$, $\gamma(t)$ is an SPD matrix. Here is some <code class="language-plaintext highlighter-rouge">JAX</code> code to get this geodesic:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">jax</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Callable</span>


<span class="k">def</span> <span class="nf">get_geodesic</span><span class="p">(</span><span class="n">P</span><span class="p">:</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="n">Op</span><span class="p">,</span> <span class="n">Sp</span><span class="p">,</span> <span class="n">OpT</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">Phalf</span> <span class="o">=</span> <span class="p">(</span><span class="n">Op</span> <span class="o">*</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">Sp</span><span class="p">))</span> <span class="o">@</span> <span class="n">OpT</span>
    <span class="n">Pmhalf</span> <span class="o">=</span> <span class="p">(</span><span class="n">Op</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">jnp</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">Sp</span><span class="p">)))</span> <span class="o">@</span> <span class="n">OpT</span>
    <span class="nb">pow</span> <span class="o">=</span> <span class="n">Pmhalf</span> <span class="o">@</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">Pmhalf</span>
    <span class="n">Opow</span><span class="p">,</span> <span class="n">Spow</span><span class="p">,</span> <span class="n">OpowT</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="nb">pow</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Phalf</span> <span class="o">@</span> <span class="p">((</span><span class="n">Opow</span> <span class="o">*</span> <span class="p">(</span><span class="n">Spow</span><span class="o">**</span><span class="n">t</span><span class="p">))</span> <span class="o">@</span> <span class="n">OpowT</span><span class="p">)</span> <span class="o">@</span> <span class="n">Phalf</span>
    <span class="k">return</span> <span class="n">gamma</span>


<span class="c1"># example usage
</span><span class="n">P1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">)</span>
<span class="n">Q1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="nf">get_geodesic</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">)</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">path</span> <span class="o">=</span> <span class="nf">vmap</span><span class="p">(</span><span class="n">gamma</span><span class="p">)(</span><span class="n">times</span><span class="p">)</span></code></pre></figure> <p>Using this code and a bit of 3D plotting, we get this gif, showing a few geodesics in the $\mathcal{S}_{++}^2$ manifold.</p> <div class="row mt-3 justify-content-center"> <div class="col-8 mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/posts/circulant_distance/geodesic.gif" alt="Geodesics in the SPD manifold."> </div> </div> <div class="caption"> A few geodesics in the $\mathcal{S}_{++}^2$ manifold. </div> <h3 id="circulant-matrices">Circulant matrices</h3> <p>Now, let’s move to <a href="https://en.wikipedia.org/wiki/Circulant_matrix" rel="external nofollow noopener" target="_blank">circulant matrices</a> that also happen to be SPD.</p> <p>Let us start from the case $n=2$. A 2 by 2, positive definite circulant matrix can be written as</p> \[\mathcal{M} = \begin{pmatrix} x &amp; z \\ z &amp; x \end{pmatrix},\] <p>with $x&gt;0$ and $|z| &lt; x$. This is a manifold, too! I will call it $\mathcal{C}<em>{++}^2$; this is a 2D manifold (one fewer dimension than $\mathcal{S}</em>{++}^2$). Specifically, it can be visualized as a slice of the cone above, obtained by intersecting it with the plane $x=y$. This is, again, a cone (at least algebraically speaking; I guess it is also geometrically a 2D cone). We can now visualize the geodesics between circulant matrices on a 2D plane.</p> <div class="row mt-3 justify-content-center"> <div class="col-8 mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/posts/circulant_distance/circ_cone.png" alt="Geodesics in the circulant cone."> </div> </div> <div class="caption"> A few geodesics in the $\mathcal{C}_{++}^2$ manifold. </div> <h3 id="geodesic-formula-for-mathcalc_n">Geodesic formula for $\mathcal{C}_{++}^n$</h3> <p>We can take the geodesic formula for $\mathcal{S}<em>{++}^n$ and specialize it to the submanifold $\mathcal{C}</em>{++}^n$. Consider $P, Q \in \mathcal{C}_{++}^n$; these are diagonalized by the <a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform" rel="external nofollow noopener" target="_blank">DFT matrix</a>, $\mathcal{F}$:</p> \[P = \mathcal{F} \Lambda_P \mathcal{F}^{-1}, \quad Q = \mathcal{F} \Lambda_Q \mathcal{F}^{-1}.\] <p>Then, we get an easier expression for $\gamma: [0, 1] \to \mathcal{C}_{++}^n$:</p> \[\gamma(t) = \mathcal{F} \frac{\Lambda_Q^t}{\Lambda_P^{t-1}} \mathcal{F}^{-1},\] <p>where the ratio and the power operation are understood to happen elementwise. As a sanity check, we see that $\gamma(0) = P$ and $\gamma(1) = Q$, as expected. The code for this geodesic is a tiny bit cleaner, as well:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">jax</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span><span class="p">,</span> <span class="n">vmap</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Callable</span>


<span class="k">def</span> <span class="nf">get_circ_geodesic</span><span class="p">(</span><span class="n">P</span><span class="p">:</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">rfft</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">lq</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">rfft</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jax</span><span class="p">.</span><span class="n">Array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">irfft</span><span class="p">(</span><span class="n">lp</span><span class="o">**</span><span class="n">t</span> <span class="o">/</span> <span class="n">lq</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">gamma</span>


<span class="c1"># example usage
</span><span class="n">P1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="p">)</span>
<span class="n">Q1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="nf">get_circ_geodesic</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">)</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">path</span> <span class="o">=</span> <span class="nf">vmap</span><span class="p">(</span><span class="n">gamma</span><span class="p">)(</span><span class="n">times</span><span class="p">)</span></code></pre></figure> <h3 id="distances">Distances</h3> <p>What about the distance between two circulant matrices? Again, we can just take the definition of distance that holds for generic SPD matrices, and use the properties of circulant matrices. We get</p> \[d(P, Q) = |\ln (\Lambda_P\cdot \Lambda_Q^{-1})|,\] <p>where $\Lambda_P, \Lambda_Q$ are the vectorized spectra of the matrices $P, Q$ (in other words, their DFT).</p> <p>TODO: find analogies in signal processing maybe?</p> <h3 id="open-questions">Open questions</h3> <p>I have one question left at the moment (hopefully, more will arise). The question is: given a matrix $P\in\mathcal{S}<em>{++}^n$, what is the *closest* matrix $Q\in \mathcal{C}</em>{++}^n$? The idea has something to do with <a href="https://arxiv.org/abs/2412.11521" rel="external nofollow noopener" target="_blank">our recent paper</a>, where we use an <em>ex-post</em> circularization procedure on Gram matrices. This circularization happens by simply averaging the diagonals of the Gram matrix. At first glance, it seems like there is no other way to make a matrix circulant that would make much sense. So it would be nice to see if it just so happens that this diagonal-averaged matrix is the “orthogonal projection” of an SPD matrix onto the submanifold of circulant SPD matrices. A possible plan of attack would be to minimize the length between an arbitrary SPD matrix $P$ and a target circulant SPD matrix $Q$. I will maybe do that in the next days.</p> <h3 id="references">References</h3> <p>A list of references:</p> <ul> <li>a definition of distance between SPD matrices: <a href="http://www.ipb.uni-bonn.de/pdfs/Forstner1999Metric.pdf" rel="external nofollow noopener" target="_blank">http://www.ipb.uni-bonn.de/pdfs/Forstner1999Metric.pdf</a> </li> <li>our recent paper: <a href="https://arxiv.org/abs/2412.11521" rel="external nofollow noopener" target="_blank">https://arxiv.org/abs/2412.11521</a> </li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Andrea Perin. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>